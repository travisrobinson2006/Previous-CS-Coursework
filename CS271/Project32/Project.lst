Microsoft (R) Macro Assembler Version 11.00.50727.1	    12/06/15 23:05:49
project06.asm						     Page 1 - 1


				; Program template
				; Travis Robinson
				; CS271
				; Fall2015
				;Assignment 6B
				;Generate Random Numbers, present as a combination problem and inform user if their answer is correct
				;Due 12.06.2015
				;robitrav@oregonstate.edu

				.386
				.model flat,stdcall
				.stack 4096
				ExitProcess proto,dwExitCode:dword
				ReadString proto
				WriteDec proto
				Crlf proto
				WriteString proto
				Randomize proto
				RandomRange proto
				Str_ucase proto,pString:PTR BYTE
				Str_compare proto,string1:ptr byte,string2:ptr byte


				;description: this macro accepts an offset to a string, and prints it to the screen
				;receives: offset to string
				;returns: N/A-prints to screen
				;preconditions: N/A ;strings declared
				;registers changed: N/A
				mSWrite MACRO string
					push edx
					mov edx,string
					call writestring
					pop edx
				endM

 00000000			.data
					; declare variables here
 00000000  00000021 [			answer byte 33 dup(?)
	    00
	   ]
 00000021 00				answer2 byte ? ;used for converting string answer to numeric answer-has no other use
 00000022  00000000			dword 0 ;used to prevent error from ptr operator below
 00000026 00000000			answer_as_number dword ? ;user enters answer as string, answer as a number gets stored here
 0000002A 00000000			numberSize dword ? ;size of string input from user
 0000002E 00000000			result dword ? ;correct answer, generated by program
 00000032 00000000			n dword ?
 00000036 00000000			r dword ?
 0000003A 00000000			n_factorial dword ?
 0000003E 00000000			r_factorial dword ?
 00000042 57 65 6C 63 6F		welcome byte "Welcome to the Combinations Calculator",0
	   6D 65 20 74 6F
	   20 74 68 65 20
	   43 6F 6D 62 69
	   6E 61 74 69 6F
	   6E 73 20 43 61
	   6C 63 75 6C 61
	   74 6F 72 00
 00000069 49 6D 70 6C 65		programmer byte "Implemented by Travis Robinson",0
	   6D 65 6E 74 65
	   64 20 62 79 20
	   54 72 61 76 69
	   73 20 52 6F 62
	   69 6E 73 6F 6E
	   00
 00000088 49 27 6C 6C 20		instructions byte "I'll give you a combinations problem. You enter your answer, and I'll let you know if you're right.",0
	   67 69 76 65 20
	   79 6F 75 20 61
	   20 63 6F 6D 62
	   69 6E 61 74 69
	   6F 6E 73 20 70
	   72 6F 62 6C 65
	   6D 2E 20 59 6F
	   75 20 65 6E 74
	   65 72 20 79 6F
	   75 72 20 61 6E
	   73 77 65 72 2C
	   20 61 6E 64 20
	   49 27 6C 6C 20
	   6C 65 74 20 79
	   6F 75 20 6B 6E
	   6F 77 20 69 66
	   20 79 6F 75 27
	   72 65 20 72 69
	   67 68 74 2E 00
 000000EC 4E 75 6D 62 65		number_elements byte "Number of elements in the set:   ",0
	   72 20 6F 66 20
	   65 6C 65 6D 65
	   6E 74 73 20 69
	   6E 20 74 68 65
	   20 73 65 74 3A
	   20 20 20 00
 0000010E 4E 75 6D 62 65		number_choose byte "Number of elements to choose from the set:   ",0
	   72 20 6F 66 20
	   65 6C 65 6D 65
	   6E 74 73 20 74
	   6F 20 63 68 6F
	   6F 73 65 20 66
	   72 6F 6D 20 74
	   68 65 20 73 65
	   74 3A 20 20 20
	   00
 0000013C 48 6F 77 20 6D		user_response byte "How many ways can you choose?   ",0
	   61 6E 79 20 77
	   61 79 73 20 63
	   61 6E 20 79 6F
	   75 20 63 68 6F
	   6F 73 65 3F 20
	   20 20 00
 0000015D 49 6E 76 61 6C		invalid_response byte "Invalid response. Re-Enter Answer: ",0
	   69 64 20 72 65
	   73 70 6F 6E 73
	   65 2E 20 52 65
	   2D 45 6E 74 65
	   72 20 41 6E 73
	   77 65 72 3A 20
	   00
 00000181 54 68 65 72 65		show_result_1 byte "There are ",0
	   20 61 72 65 20
	   00
 0000018C 20 63 6F 6D 62		show_result_2 byte " combinations of ",0
	   69 6E 61 74 69
	   6F 6E 73 20 6F
	   66 20 00
 0000019E 20 66 72 6F 6D		show_result_3 byte " from a set of ",0
	   20 61 20 73 65
	   74 20 6F 66 20
	   00
 000001AE 59 6F 75 20 61		correct_result byte "You are correct!",0
	   72 65 20 63 6F
	   72 72 65 63 74
	   21 00
 000001BF 59 6F 75 20 6E		incorrect_result byte "You need more practice.",0
	   65 65 64 20 6D
	   6F 72 65 20 70
	   72 61 63 74 69
	   63 65 2E 00
 000001D7 41 6E 6F 74 68		user_redo byte "Another problem? (y/n):   ",0
	   65 72 20 70 72
	   6F 62 6C 65 6D
	   3F 20 28 79 2F
	   6E 29 3A 20 20
	   20 00
 000001F2 49 6E 76 61 6C		user_redo_invalid byte "Invalid response. Another problem? (y/n):   ",0
	   69 64 20 72 65
	   73 70 6F 6E 73
	   65 2E 20 41 6E
	   6F 74 68 65 72
	   20 70 72 6F 62
	   6C 65 6D 3F 20
	   28 79 2F 6E 29
	   3A 20 20 20 00
 0000021F 59 00				yes byte "Y",0
 00000221 4E 00				no byte "N",0
 00000223  00000021 [			redo_response byte 33 dup(?) ;user input string to determine if they want to do another problem
	    00
	   ]
 00000244 4F 6B 2E 2E 2E		goodbye byte "Ok...goodbye.",0
	   67 6F 6F 64 62
	   79 65 2E 00

 00000000			.code
 00000000			main proc
					; write your code here
 00000000  E8 00000000 E		call randomize
					
					;deliver user instructions
 00000005  68 00000088 R		push offset instructions
 0000000A  68 00000069 R		push offset programmer
 0000000F  68 00000042 R		push offset welcome
 00000014  E8 00000316			call introduction

 00000019			Redo:	;come up here if user wants to redo

					;initizialize here in case user wants to redo
 00000019  C7 05 0000003A R		mov n_factorial,1
	   00000001
 00000023  C7 05 0000003E R		mov r_factorial,1
	   00000001
 0000002D  C7 05 00000026 R		mov answer_as_number,0
	   00000000

					;present user with problem
 00000037  68 000000EC R		push offset number_elements
 0000003C  68 0000010E R		push offset number_choose
 00000041  68 00000036 R		push offset r
 00000046  68 00000032 R		push offset n
 0000004B  E8 00000252			call showProblem

					;get user response to problem
 00000050  68 0000015D R		push offset invalid_response
 00000055  68 00000026 R		push offset answer_as_number
 0000005A  68 00000021 R		push offset answer2
 0000005F  68 0000002A R		push offset numberSize
 00000064  68 0000013C R		push offset user_response
 00000069  68 00000000 R		push offset answer
 0000006E  6A 21			push sizeof answer
 00000070  E8 0000019A			call getData

					;mov eax,answer_as_number
					;call writedec

					;find correct answer
 00000075  68 0000002E R		push offset result
 0000007A  FF 35 00000032 R		push n
 00000080  68 0000003A R		push offset n_factorial
 00000085  FF 35 00000036 R		push r
 0000008B  68 0000003E R		push offset r_factorial
 00000090  E8 0000011D			call combinations

					;tell user if they were correct or not
 00000095  68 000001AE R		push offset correct_result
 0000009A  68 000001BF R		push offset incorrect_result
 0000009F  68 00000181 R		push offset show_result_1
 000000A4  68 0000018C R		push offset show_result_2
 000000A9  68 0000019E R		push offset show_result_3
 000000AE  FF 35 00000032 R		push n
 000000B4  FF 35 00000036 R		push r
 000000BA  FF 35 00000026 R		push answer_as_number
 000000C0  FF 35 0000002E R		push result
 000000C6  E8 0000007B			call showResult

					;ask user if they want to redo; if so jump to redo
 000000CB			AskUserRedo:
 000000CB  E8 00000000 E		call crlf
					mSWrite offset user_redo
 000000D0  52		     1		push edx
 000000D1  BA 000001D7 R     1		mov edx,offset user_redo
 000000D6  E8 00000000 E     1		call writestring
 000000DB  5A		     1		pop edx
 000000DC  BA 00000223 R		mov edx, offset redo_response
 000000E1  B9 00000021			mov ecx, sizeof redo_response
 000000E6  E8 00000000 E		call readstring
 000000EB  E8 00000000 E		call crlf	
					invoke Str_ucase, ADDR redo_response
 000000F0  68 00000223 R   *	    push   OFFSET redo_response
 000000F5  E8 00000000 E   *	    call   Str_ucase
					invoke Str_compare, ADDR redo_response, ADDR yes
 000000FA  68 0000021F R   *	    push   OFFSET yes
 000000FF  68 00000223 R   *	    push   OFFSET redo_response
 00000104  E8 00000000 E   *	    call   Str_compare
 00000109  0F 84 FFFFFF0A		je redo

					;ask again if user gives invalid answer
					invoke Str_compare, ADDR redo_response, ADDR no
 0000010F  68 00000221 R   *	    push   OFFSET no
 00000114  68 00000223 R   *	    push   OFFSET redo_response
 00000119  E8 00000000 E   *	    call   Str_compare
 0000011E  74 0E			je dontRedo
					mSWrite offset user_redo_invalid
 00000120  52		     1		push edx
 00000121  BA 000001F2 R     1		mov edx,offset user_redo_invalid
 00000126  E8 00000000 E     1		call writestring
 0000012B  5A		     1		pop edx
 0000012C  EB 9D			jmp AskUserRedo

					;user chooses not to redo
 0000012E			dontRedo:
					mSWrite offset goodbye
 0000012E  52		     1		push edx
 0000012F  BA 00000244 R     1		mov edx,offset goodbye
 00000134  E8 00000000 E     1		call writestring
 00000139  5A		     1		pop edx
 0000013A  E8 00000000 E		call crlf
					invoke ExitProcess,0
 0000013F  6A 00	   *	    push   +000000000h
 00000141  E8 00000000 E   *	    call   ExitProcess
 00000146			main endp

				;description: displays correct answer and determines if user is correct or not
				;receives: n,r,user answer,correct answer
				;returns: N/A-prints to screen
				;preconditions: N/A ;user answer entered, correct answer calculated, n and r initialized
				;registers changed: N/A

 00000146			showResult proc
 00000146  55				push ebp
 00000147  8B EC			mov ebp,esp
 00000149  50				push eax
 0000014A  53				push ebx
 0000014B  51				push ecx
 0000014C  52				push edx
					
				;print strings and values from problem, correct answer
					mSWrite [ebp+32]
 0000014D  52		     1		push edx
 0000014E  8B 55 20	     1		mov edx,[ebp+32]
 00000151  E8 00000000 E     1		call writestring
 00000156  5A		     1		pop edx
 00000157  8B 45 08			mov eax,[ebp+8]
 0000015A  E8 00000000 E		call writedec
					mSWrite [ebp+28]
 0000015F  52		     1		push edx
 00000160  8B 55 1C	     1		mov edx,[ebp+28]
 00000163  E8 00000000 E     1		call writestring
 00000168  5A		     1		pop edx
 00000169  8B 45 10			mov eax,[ebp+16]
 0000016C  E8 00000000 E		call writedec
					mSWrite [ebp+24]
 00000171  52		     1		push edx
 00000172  8B 55 18	     1		mov edx,[ebp+24]
 00000175  E8 00000000 E     1		call writestring
 0000017A  5A		     1		pop edx
 0000017B  8B 45 14			mov eax,[ebp+20]
 0000017E  E8 00000000 E		call writedec
 00000183  E8 00000000 E		call crlf

				;figure out if user has correct answer
 00000188  8B 45 08			mov eax,[ebp+8]
 0000018B  8B 5D 0C			mov ebx,[ebp+12]
 0000018E  3B C3			cmp eax,ebx
 00000190  74 0C			je correct

				;user needs more practice
 00000192			Incorrect:
					mSWrite [ebp+36]
 00000192  52		     1		push edx
 00000193  8B 55 24	     1		mov edx,[ebp+36]
 00000196  E8 00000000 E     1		call writestring
 0000019B  5A		     1		pop edx
 0000019C  EB 0C			jmp endShowResult

				;user finds correct answer
 0000019E			Correct:
					mSWrite [ebp+40]
 0000019E  52		     1		push edx
 0000019F  8B 55 28	     1		mov edx,[ebp+40]
 000001A2  E8 00000000 E     1		call writestring
 000001A7  5A		     1		pop edx
 000001A8  EB 00			jmp endShowResult

 000001AA			endShowResult:
 000001AA  5A				pop edx
 000001AB  59				pop ecx
 000001AC  5B				pop ebx
 000001AD  58				pop eax
 000001AE  5D				pop ebp
 000001AF  C2 0024			ret 36
 000001B2			showResult endp

				;description: determines correct answer to combination problem
				;receives: offset to result, n_factorial and r_factorial, recieves n and r as values
				;returns: N/A-correct answer to result,n_factorial and r_factorial within their memory locations
				;preconditions: N/A ;n and r initilaized, factorial values initialized to 1
				;registers changed: N/A

 000001B2			combinations proc
 000001B2  55				push ebp
 000001B3  8B EC			mov ebp,esp
 000001B5  52				push edx
 000001B6  51				push ecx
 000001B7  53				push ebx
 000001B8  50				push eax	

					;mov eax,[ebp+12] ; r
					;mov eax,[ebp+20] ; n


 000001B9  FF 75 14			push [ebp+20] ;n
 000001BC  FF 75 10			push [ebp+16] ;n_factorial
 000001BF  E8 00000140			call factorial

					;mov eax, n_factorial
					;call writedec
					;call crlf

 000001C4  FF 75 0C			push [ebp+12] ;r
 000001C7  FF 75 08			push [ebp+8] ;r_factorial
 000001CA  E8 00000135			call factorial

					;mov eax, r_factorial
					;call writedec
					;call crlf

 000001CF  8B 45 14			mov eax,[ebp+20]
 000001D2  2B 45 0C			sub eax,[ebp+12] ;n-r
					;call writedec
					;call crlf

 000001D5  8B 5D 18			mov ebx,[ebp+24]
 000001D8  B9 00000001			mov ecx,1
 000001DD  89 0B			mov [ebx],ecx
					
					;mov ebx,[ebp+24]
					;mov eax,[ebx]
					;mov eax,result
					;call writedec
					;call crlf

 000001DF  50				push eax
 000001E0  FF 75 18			push [ebp+24]
 000001E3  E8 0000011C			call factorial ;n-r factorial, storing in result to save memory
					;mov eax,result
					;call writedec
					;call crlf	

 000001E8  8B 55 18			mov edx,[ebp+24];n-r
 000001EB  8B 12			mov edx,[edx]
 000001ED  8B 4D 10			mov ecx,[ebp+16];n
 000001F0  8B 09			mov ecx,[ecx]
 000001F2  8B 5D 08			mov ebx,[ebp+8];r
 000001F5  8B 1B			mov ebx,[ebx]

 000001F7  8B C2			mov eax,edx
 000001F9  99				cdq
 000001FA  F7 E3			mul ebx
 000001FC  8B D8			mov ebx,eax
 000001FE  8B C1			mov eax,ecx
 00000200  F7 F3			div ebx

 00000202  8B 5D 18			mov ebx,[ebp+24]
 00000205  89 03			mov [ebx],eax

					;mov eax,result
					;call writedec
					;call crlf

 00000207  58				pop eax
 00000208  5B				pop ebx
 00000209  59				pop ecx
 0000020A  5A				pop edx
 0000020B  5D				pop ebp
 0000020C  C2 0014			ret 20
 0000020F			combinations endp

				;description: retrieves user answer to combination problem
				;receives: offset to answer, answer_as_number,answer2,numbersize; size of answer as value, and offset to invalid response string for if user provides invalid response
				;returns: N/A-fills answer_to_number with correct value
				;preconditions: values exist, answer as number is initialized to 0
				;registers changed: N/A

 0000020F			getData proc
 0000020F  55				push ebp
 00000210  8B EC			mov ebp,esp
 00000212  52				push edx
 00000213  51				push ecx
 00000214  53				push ebx
 00000215  50				push eax


					mSWrite [ebp+16]
 00000216  52		     1		push edx
 00000217  8B 55 10	     1		mov edx,[ebp+16]
 0000021A  E8 00000000 E     1		call writestring
 0000021F  5A		     1		pop edx

 00000220			startGetData:
					;mov edx, offset answer
					;mov ecx, sizeof answer
 00000220  8B 55 0C			mov edx,[ebp+12]
 00000223  8B 4D 08			mov ecx,[ebp+8]
					
 00000226  E8 00000000 E		call readstring
 0000022B  8B 55 14			mov edx,[ebp+20]
 0000022E  89 02			mov [edx],eax
					
					;mov numberSize,eax 
 00000230  8B 0A			mov ecx,[edx]
					
 00000232  BA 00000000			mov edx,0
					
					;mov answer_as_number, 0
					;push ebx
					;mov ebx,[ebp+28]
					;mov ebx,0
					;pop ebx

 00000237			readNumbers:
 00000237  53				push ebx
 00000238  8B 5D 0C			mov ebx,[ebp+12]
 0000023B  B8 00000000			mov eax, 0

					;mov answer2,0
 00000240  53				push ebx
 00000241  8B 5D 18			mov ebx,[ebp+24]
 00000244  BB 00000000			mov ebx,0
 00000249  5B				pop ebx

					;see if value is within approriate range on ascii table
 0000024A  8A 04 1A			mov al, [ebx+edx]
 0000024D  5B				pop ebx
 0000024E  3C 30			cmp al,48
 00000250  7C 3C			jl invalidInput
 00000252  3C 39			cmp al,57
 00000254  7F 38			jg invalidInput

					;turn ascii value into number
 00000256  2C 30			sub al,48

					;mov answer2, al
 00000258  53				push ebx
 00000259  8B 5D 18			mov ebx,[ebp+24]
 0000025C  88 03			mov [ebx],al
 0000025E  5B				pop ebx
					
					;mov eax, dword ptr answer2
 0000025F  53				push ebx
 00000260  8B 5D 18			mov ebx,[ebp+24]
 00000263  8B 03			mov eax, dword ptr [ebx] ;use ptr because of differences in value size
 00000265  5B				pop ebx

					
 00000266  52				push edx
 00000267  8B D9			mov ebx,ecx
 00000269  83 FB 01			cmp ebx,1
 0000026C  7E 0D			jle dontMultiply
 0000026E  BF 0000000A			mov edi,10
 00000273				multiply: ;multiply digit by number of times to get it in correct space of number
 00000273  F7 E7				mul edi
 00000275  4B					dec ebx
 00000276  83 FB 01				cmp ebx,1
 00000279  7F F8				jg multiply

 0000027B				dontMultiply:;come here if last number;no need to multiply
					
					;call writedec
					;call crlf
 0000027B  5A				pop edx
					
 0000027C  01 05 00000026 R		add answer_as_number, eax
 00000282  53				push ebx
 00000283  8B 5D 1C			mov ebx,[ebp+28]
 00000286  03 D8			add ebx,eax
 00000288  5B				pop ebx	

 00000289  42				inc edx

 0000028A  E2 AB		loop readNumbers
 0000028C  EB 0C		jmp endReading
 0000028E			invalidInput:
					mSWrite [ebp+32]
 0000028E  52		     1		push edx
 0000028F  8B 55 20	     1		mov edx,[ebp+32]
 00000292  E8 00000000 E     1		call writestring
 00000297  5A		     1		pop edx
 00000298  EB 86			jmp startGetData
 0000029A			endReading:
					;mov eax,answer_as_number
					;call writedec
					;call crlf
 0000029A  58				pop eax
 0000029B  5B				pop ebx
 0000029C  59				pop ecx
 0000029D  5A				pop edx
 0000029E  5D				pop ebp
 0000029F  C2 0014			ret 20
 000002A2			getData endp

				;description: displays problem for user
				;receives: offsets to n and r, offsets to strings that need to be printed
				;returns: n and r filled with random values
				;preconditions: n and r initilaized, random number seeded
				;registers changed: N/A

 000002A2			showProblem proc
 000002A2  55				push ebp
 000002A3  8B EC			mov ebp,esp
 000002A5  52				push edx
 000002A6  51				push ecx
 000002A7  53				push ebx
 000002A8  50				push eax


 000002A9  8B 55 08			mov edx,[ebp+8];n
 000002AC  8B 4D 0C			mov ecx,[ebp+12];r

					;generate n
 000002AF  B8 0000000C			mov eax,12
 000002B4  83 E8 03			sub eax,3
 000002B7  E8 00000000 E		call randomrange
 000002BC  83 C0 03			add eax,3
 000002BF  89 02			mov[edx],eax

					;generate r
 000002C1  8B 02			mov eax,[edx]
 000002C3  83 E8 01			sub eax,1
 000002C6  E8 00000000 E		call randomrange
 000002CB  83 C0 01			add eax,1
 000002CE  89 01			mov [ecx],eax

					;print problem for user
					mSWrite [ebp+20]		
 000002D0  52		     1		push edx
 000002D1  8B 55 14	     1		mov edx,[ebp+20]
 000002D4  E8 00000000 E     1		call writestring
 000002D9  5A		     1		pop edx
 000002DA  8B 02			mov eax,[edx]
 000002DC  E8 00000000 E		call writedec
 000002E1  E8 00000000 E		call crlf
					
					mSWrite [ebp+16]
 000002E6  52		     1		push edx
 000002E7  8B 55 10	     1		mov edx,[ebp+16]
 000002EA  E8 00000000 E     1		call writestring
 000002EF  5A		     1		pop edx
 000002F0  8B 01			mov eax,[ecx]
 000002F2  E8 00000000 E		call writedec
 000002F7  E8 00000000 E		call crlf

 000002FC  58				pop eax
 000002FD  5B				pop ebx
 000002FE  59				pop ecx
 000002FF  5A				pop edx
 00000300  5D				pop ebp
 00000301  C2 0018			ret 24
 00000304			showProblem endp

				;description: finds factorial of input number
				;receives: offset to factorial number, and number that needs to factorialed by value
				;returns: offset number is filled with correct number (ie, if n and n_factorial are passed, fills n_factorial with correct factorial)
				;preconditions: value passed is a number, factorial values initialized to 1
				;registers changed: N/A

 00000304			factorial proc
 00000304  55				push ebp
 00000305  8B EC			mov ebp,esp
 00000307  50				push eax
 00000308  53				push ebx
 00000309  51				push ecx
 0000030A  52				push edx

 0000030B  8B 4D 08			mov ecx,[ebp+8] ;if number is 1, no need to multiply--base case
 0000030E  8B 45 0C			mov eax,[ebp+12]
 00000311  83 F8 01			cmp eax,1
 00000314  7E 11			jle exitRecurse
					
					;call writedec
					;call crlf
					
					;decrement and multiply into x_factorial
 00000316  8B 19			mov ebx,[ecx]
 00000318  F7 E3			mul ebx
 0000031A  89 01			mov [ecx],eax
 0000031C  8B 45 0C			mov eax,[ebp+12]
 0000031F  48				dec eax

					;push x_factorial,decremented value of x, recursively call
 00000320  50				push eax
 00000321  51				push ecx
 00000322  E8 FFFFFFDD			call factorial

 00000327			exitRecurse:
 00000327  5A				pop edx
 00000328  59				pop ecx
 00000329  5B				pop ebx
 0000032A  58				pop eax

 0000032B  5D				pop ebp
 0000032C  C2 0008			ret 8
 0000032F			factorial endp

				;description: prints program name,programmer name, instructions
				;receives: offset to relevant strings
				;returns: N/A-prints to screen
				;preconditions: strings initialized
				;registers changed: N/A

 0000032F			introduction proc
 0000032F  55				push ebp
 00000330  8B EC			mov ebp,esp
					mSWrite [ebp+8] ;use macro for printing (this a lot easier!)
 00000332  52		     1		push edx
 00000333  8B 55 08	     1		mov edx,[ebp+8]
 00000336  E8 00000000 E     1		call writestring
 0000033B  5A		     1		pop edx
 0000033C  E8 00000000 E		call crlf
					mSWrite [ebp+12]
 00000341  52		     1		push edx
 00000342  8B 55 0C	     1		mov edx,[ebp+12]
 00000345  E8 00000000 E     1		call writestring
 0000034A  5A		     1		pop edx
 0000034B  E8 00000000 E		call crlf
					mSWrite [ebp+16]
 00000350  52		     1		push edx
 00000351  8B 55 10	     1		mov edx,[ebp+16]
 00000354  E8 00000000 E     1		call writestring
 00000359  5A		     1		pop edx
 0000035A  E8 00000000 E		call crlf
 0000035F  5D				pop ebp
 00000360  C2 000C			ret 12
 00000363			introduction endp

				end main

Microsoft (R) Macro Assembler Version 11.00.50727.1	    12/06/15 23:05:49
project06.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

mSWrite  . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000252 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000363 DWord	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
combinations . . . . . . . . . .	P Near	 000001B2 _TEXT	Length= 0000005D Public STDCALL
factorial  . . . . . . . . . . .	P Near	 00000304 _TEXT	Length= 0000002B Public STDCALL
  exitRecurse  . . . . . . . . .	L Near	 00000327 _TEXT	
getData  . . . . . . . . . . . .	P Near	 0000020F _TEXT	Length= 00000093 Public STDCALL
  startGetData . . . . . . . . .	L Near	 00000220 _TEXT	
  readNumbers  . . . . . . . . .	L Near	 00000237 _TEXT	
  multiply . . . . . . . . . . .	L Near	 00000273 _TEXT	
  dontMultiply . . . . . . . . .	L Near	 0000027B _TEXT	
  invalidInput . . . . . . . . .	L Near	 0000028E _TEXT	
  endReading . . . . . . . . . .	L Near	 0000029A _TEXT	
introduction . . . . . . . . . .	P Near	 0000032F _TEXT	Length= 00000034 Public STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000146 Public STDCALL
  Redo . . . . . . . . . . . . .	L Near	 00000019 _TEXT	
  AskUserRedo  . . . . . . . . .	L Near	 000000CB _TEXT	
  dontRedo . . . . . . . . . . .	L Near	 0000012E _TEXT	
showProblem  . . . . . . . . . .	P Near	 000002A2 _TEXT	Length= 00000062 Public STDCALL
showResult . . . . . . . . . . .	P Near	 00000146 _TEXT	Length= 0000006C Public STDCALL
  Incorrect  . . . . . . . . . .	L Near	 00000192 _TEXT	
  Correct  . . . . . . . . . . .	L Near	 0000019E _TEXT	
  endShowResult  . . . . . . . .	L Near	 000001AA _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
answer2  . . . . . . . . . . . .	Byte	 00000021 _DATA	
answer_as_number . . . . . . . .	DWord	 00000026 _DATA	
answer . . . . . . . . . . . . .	Byte	 00000000 _DATA	
correct_result . . . . . . . . .	Byte	 000001AE _DATA	
goodbye  . . . . . . . . . . . .	Byte	 00000244 _DATA	
incorrect_result . . . . . . . .	Byte	 000001BF _DATA	
instructions . . . . . . . . . .	Byte	 00000088 _DATA	
invalid_response . . . . . . . .	Byte	 0000015D _DATA	
n_factorial  . . . . . . . . . .	DWord	 0000003A _DATA	
no . . . . . . . . . . . . . . .	Byte	 00000221 _DATA	
numberSize . . . . . . . . . . .	DWord	 0000002A _DATA	
number_choose  . . . . . . . . .	Byte	 0000010E _DATA	
number_elements  . . . . . . . .	Byte	 000000EC _DATA	
n  . . . . . . . . . . . . . . .	DWord	 00000032 _DATA	
programmer . . . . . . . . . . .	Byte	 00000069 _DATA	
r_factorial  . . . . . . . . . .	DWord	 0000003E _DATA	
redo_response  . . . . . . . . .	Byte	 00000223 _DATA	
result . . . . . . . . . . . . .	DWord	 0000002E _DATA	
r  . . . . . . . . . . . . . . .	DWord	 00000036 _DATA	
show_result_1  . . . . . . . . .	Byte	 00000181 _DATA	
show_result_2  . . . . . . . . .	Byte	 0000018C _DATA	
show_result_3  . . . . . . . . .	Byte	 0000019E _DATA	
user_redo_invalid  . . . . . . .	Byte	 000001F2 _DATA	
user_redo  . . . . . . . . . . .	Byte	 000001D7 _DATA	
user_response  . . . . . . . . .	Byte	 0000013C _DATA	
welcome  . . . . . . . . . . . .	Byte	 00000042 _DATA	
yes  . . . . . . . . . . . . . .	Byte	 0000021F _DATA	

	   0 Warnings
	   0 Errors
