; Program template
; Travis Robinson
; CS271
; Fall2015
;Assignment 6B
;Generate Random Numbers, present as a combination problem and inform user if their answer is correct
;Due 12.06.2015
;robitrav@oregonstate.edu

.386
.model flat,stdcall
.stack 4096
ExitProcess proto,dwExitCode:dword
ReadString proto
WriteDec proto
Crlf proto
WriteString proto
Randomize proto
RandomRange proto
Str_ucase proto,pString:PTR BYTE
Str_compare proto,string1:ptr byte,string2:ptr byte


;description: this macro accepts an offset to a string, and prints it to the screen
;receives: offset to string
;returns: N/A-prints to screen
;preconditions: N/A ;strings declared
;registers changed: N/A
mSWrite MACRO string
	push edx
	mov edx,string
	call writestring
	pop edx
endM

.data
	; declare variables here
	answer byte 33 dup(?)
	answer2 byte ? ;used for converting string answer to numeric answer-has no other use
	dword 0 ;used to prevent error from ptr operator below
	answer_as_number dword ? ;user enters answer as string, answer as a number gets stored here
	numberSize dword ? ;size of string input from user
	result dword ? ;correct answer, generated by program
	n dword ?
	r dword ?
	n_factorial dword ?
	r_factorial dword ?
	welcome byte "Welcome to the Combinations Calculator",0
	programmer byte "Implemented by Travis Robinson",0
	instructions byte "I'll give you a combinations problem. You enter your answer, and I'll let you know if you're right.",0
	number_elements byte "Number of elements in the set:   ",0
	number_choose byte "Number of elements to choose from the set:   ",0
	user_response byte "How many ways can you choose?   ",0
	invalid_response byte "Invalid response. Re-Enter Answer: ",0
	show_result_1 byte "There are ",0
	show_result_2 byte " combinations of ",0
	show_result_3 byte " from a set of ",0
	correct_result byte "You are correct!",0
	incorrect_result byte "You need more practice.",0
	user_redo byte "Another problem? (y/n):   ",0
	user_redo_invalid byte "Invalid response. Another problem? (y/n):   ",0
	yes byte "Y",0
	no byte "N",0
	redo_response byte 33 dup(?) ;user input string to determine if they want to do another problem
	goodbye byte "Ok...goodbye.",0

.code
main proc
	; write your code here
	call randomize
	
	;deliver user instructions
	push offset instructions
	push offset programmer
	push offset welcome
	call introduction

Redo:	;come up here if user wants to redo

	;initizialize here in case user wants to redo
	mov n_factorial,1
	mov r_factorial,1
	mov answer_as_number,0

	;present user with problem
	push offset number_elements
	push offset number_choose
	push offset r
	push offset n
	call showProblem

	;get user response to problem
	push offset invalid_response
	push offset answer_as_number
	push offset answer2
	push offset numberSize
	push offset user_response
	push offset answer
	push sizeof answer
	call getData

	;mov eax,answer_as_number
	;call writedec

	;find correct answer
	push offset result
	push n
	push offset n_factorial
	push r
	push offset r_factorial
	call combinations

	;tell user if they were correct or not
	push offset correct_result
	push offset incorrect_result
	push offset show_result_1
	push offset show_result_2
	push offset show_result_3
	push n
	push r
	push answer_as_number
	push result
	call showResult

	;ask user if they want to redo; if so jump to redo
AskUserRedo:
	call crlf
	mSWrite offset user_redo
	mov edx, offset redo_response
	mov ecx, sizeof redo_response
	call readstring
	call crlf	
	invoke Str_ucase, ADDR redo_response
	invoke Str_compare, ADDR redo_response, ADDR yes
	je redo

	;ask again if user gives invalid answer
	invoke Str_compare, ADDR redo_response, ADDR no
	je dontRedo
	mSWrite offset user_redo_invalid
	jmp AskUserRedo

	;user chooses not to redo
dontRedo:
	mSWrite offset goodbye
	call crlf
	invoke ExitProcess,0
main endp

;description: displays correct answer and determines if user is correct or not
;receives: n,r,user answer,correct answer
;returns: N/A-prints to screen
;preconditions: N/A ;user answer entered, correct answer calculated, n and r initialized
;registers changed: N/A

showResult proc
	push ebp
	mov ebp,esp
	push eax
	push ebx
	push ecx
	push edx
	
;print strings and values from problem, correct answer
	mSWrite [ebp+32]
	mov eax,[ebp+8]
	call writedec
	mSWrite [ebp+28]
	mov eax,[ebp+16]
	call writedec
	mSWrite [ebp+24]
	mov eax,[ebp+20]
	call writedec
	call crlf

;figure out if user has correct answer
	mov eax,[ebp+8]
	mov ebx,[ebp+12]
	cmp eax,ebx
	je correct

;user needs more practice
Incorrect:
	mSWrite [ebp+36]
	jmp endShowResult

;user finds correct answer
Correct:
	mSWrite [ebp+40]
	jmp endShowResult

endShowResult:
	pop edx
	pop ecx
	pop ebx
	pop eax
	pop ebp
	ret 36
showResult endp

;description: determines correct answer to combination problem
;receives: offset to result, n_factorial and r_factorial, recieves n and r as values
;returns: N/A-correct answer to result,n_factorial and r_factorial within their memory locations
;preconditions: N/A ;n and r initilaized, factorial values initialized to 1
;registers changed: N/A

combinations proc
	push ebp
	mov ebp,esp
	push edx
	push ecx
	push ebx
	push eax	

	;mov eax,[ebp+12] ; r
	;mov eax,[ebp+20] ; n


	push [ebp+20] ;n
	push [ebp+16] ;n_factorial
	call factorial

	;mov eax, n_factorial
	;call writedec
	;call crlf

	push [ebp+12] ;r
	push [ebp+8] ;r_factorial
	call factorial

	;mov eax, r_factorial
	;call writedec
	;call crlf

	mov eax,[ebp+20]
	sub eax,[ebp+12] ;n-r
	;call writedec
	;call crlf

	mov ebx,[ebp+24]
	mov ecx,1
	mov [ebx],ecx
	
	;mov ebx,[ebp+24]
	;mov eax,[ebx]
	;mov eax,result
	;call writedec
	;call crlf

	push eax
	push [ebp+24]
	call factorial ;n-r factorial, storing in result to save memory
	;mov eax,result
	;call writedec
	;call crlf	

	mov edx,[ebp+24];n-r
	mov edx,[edx]
	mov ecx,[ebp+16];n
	mov ecx,[ecx]
	mov ebx,[ebp+8];r
	mov ebx,[ebx]

	mov eax,edx
	cdq
	mul ebx
	mov ebx,eax
	mov eax,ecx
	div ebx

	mov ebx,[ebp+24]
	mov [ebx],eax

	;mov eax,result
	;call writedec
	;call crlf

	pop eax
	pop ebx
	pop ecx
	pop edx
	pop ebp
	ret 20
combinations endp

;description: retrieves user answer to combination problem
;receives: offset to answer, answer_as_number,answer2,numbersize; size of answer as value, and offset to invalid response string for if user provides invalid response
;returns: N/A-fills answer_to_number with correct value
;preconditions: values exist, answer as number is initialized to 0
;registers changed: N/A

getData proc
	push ebp
	mov ebp,esp
	push edx
	push ecx
	push ebx
	push eax


	mSWrite [ebp+16]

startGetData:
	;mov edx, offset answer
	;mov ecx, sizeof answer
	mov edx,[ebp+12]
	mov ecx,[ebp+8]
	
	call readstring
	mov edx,[ebp+20]
	mov [edx],eax
	
	;mov numberSize,eax 
	mov ecx,[edx]
	
	mov edx,0
	
	;mov answer_as_number, 0
	;push ebx
	;mov ebx,[ebp+28]
	;mov ebx,0
	;pop ebx

readNumbers:
	push ebx
	mov ebx,[ebp+12]
	mov eax, 0

	;mov answer2,0
	push ebx
	mov ebx,[ebp+24]
	mov ebx,0
	pop ebx

	;see if value is within approriate range on ascii table
	mov al, [ebx+edx]
	pop ebx
	cmp al,48
	jl invalidInput
	cmp al,57
	jg invalidInput

	;turn ascii value into number
	sub al,48

	;mov answer2, al
	push ebx
	mov ebx,[ebp+24]
	mov [ebx],al
	pop ebx
	
	;mov eax, dword ptr answer2
	push ebx
	mov ebx,[ebp+24]
	mov eax, dword ptr [ebx] ;use ptr because of differences in value size
	pop ebx

	
	push edx
	mov ebx,ecx
	cmp ebx,1
	jle dontMultiply
	mov edi,10
	multiply: ;multiply digit by number of times to get it in correct space of number
		mul edi
		dec ebx
		cmp ebx,1
		jg multiply

	dontMultiply:;come here if last number;no need to multiply
	
	;call writedec
	;call crlf
	pop edx
	
	add answer_as_number, eax
	push ebx
	mov ebx,[ebp+28]
	add ebx,eax
	pop ebx	

	inc edx

loop readNumbers
jmp endReading
invalidInput:
	mSWrite [ebp+32]
	jmp startGetData
endReading:
	;mov eax,answer_as_number
	;call writedec
	;call crlf
	pop eax
	pop ebx
	pop ecx
	pop edx
	pop ebp
	ret 20
getData endp

;description: displays problem for user
;receives: offsets to n and r, offsets to strings that need to be printed
;returns: n and r filled with random values
;preconditions: n and r initilaized, random number seeded
;registers changed: N/A

showProblem proc
	push ebp
	mov ebp,esp
	push edx
	push ecx
	push ebx
	push eax


	mov edx,[ebp+8];n
	mov ecx,[ebp+12];r

	;generate n
	mov eax,12
	sub eax,3
	call randomrange
	add eax,3
	mov[edx],eax

	;generate r
	mov eax,[edx]
	sub eax,1
	call randomrange
	add eax,1
	mov [ecx],eax

	;print problem for user
	mSWrite [ebp+20]		
	mov eax,[edx]
	call writedec
	call crlf
	
	mSWrite [ebp+16]
	mov eax,[ecx]
	call writedec
	call crlf

	pop eax
	pop ebx
	pop ecx
	pop edx
	pop ebp
	ret 24
showProblem endp

;description: finds factorial of input number
;receives: offset to factorial number, and number that needs to factorialed by value
;returns: offset number is filled with correct number (ie, if n and n_factorial are passed, fills n_factorial with correct factorial)
;preconditions: value passed is a number, factorial values initialized to 1
;registers changed: N/A

factorial proc
	push ebp
	mov ebp,esp
	push eax
	push ebx
	push ecx
	push edx

	mov ecx,[ebp+8] ;if number is 1, no need to multiply--base case
	mov eax,[ebp+12]
	cmp eax,1
	jle exitRecurse
	
	;call writedec
	;call crlf
	
	;decrement and multiply into x_factorial
	mov ebx,[ecx]
	mul ebx
	mov [ecx],eax
	mov eax,[ebp+12]
	dec eax

	;push x_factorial,decremented value of x, recursively call
	push eax
	push ecx
	call factorial

exitRecurse:
	pop edx
	pop ecx
	pop ebx
	pop eax

	pop ebp
	ret 8
factorial endp

;description: prints program name,programmer name, instructions
;receives: offset to relevant strings
;returns: N/A-prints to screen
;preconditions: strings initialized
;registers changed: N/A

introduction proc
	push ebp
	mov ebp,esp
	mSWrite [ebp+8] ;use macro for printing (this a lot easier!)
	call crlf
	mSWrite [ebp+12]
	call crlf
	mSWrite [ebp+16]
	call crlf
	pop ebp
	ret 12
introduction endp

end main

